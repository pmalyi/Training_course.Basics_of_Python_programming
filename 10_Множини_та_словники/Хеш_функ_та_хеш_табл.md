## Хеш-функції та Хеш-таблиці в Python

### Проблема швидкого пошуку
Уявіть, що у вас є величезний список імен, і вам потрібно перевірити, чи є в ньому ім'я "Іван".
```python
names = ["Анна", "Петро", "Сергій", ..., "Іван", ..., "Ольга"] # мільйон імен
# Щоб знайти "Іван", вам доведеться переглядати список елемент за елементом.
# У найгіршому випадку, ви пройдете весь список. Це довго!
```
А що, якби існував спосіб миттєво дізнатися, де саме шукати?

**Аналогія з бібліотекою:**
*   **Список (list):** Це як зберігати всі книги в одній великій купі. Щоб знайти потрібну, 
треба переглянути всі.
*   **Хеш-таблиця (hash table):** Це як організована бібліотека, де кожна книга має свій шифр 
(наприклад, за автором та назвою), який вказує на конкретну полицю. Ви не шукаєте по всій 
бібліотеці, а одразу йдете до потрібної полиці.

**Хеш-таблиця** — це структура даних, яка вирішує проблему повільного пошуку, дозволяючи 
отримувати доступ до даних майже миттєво.

### Частина 1: Хеш-функція — "магічний сортувальник"

**Що таке хеш-функція?**
Це функція, яка приймає на вхід дані будь-якого розміру (наприклад, рядок, число) і перетворює 
їх на вихідне значення фіксованого розміру — **хеш-код** або просто **хеш**.

`Вхідні дані (ключ) -> [ Хеш-функція ] -> Хеш-код (ціле число)`

**Основні властивості ідеальної хеш-функції:**
1.  **Детермінізм (Determinism):** Однаковий вхідний ключ **завжди** дає однаковий хеш-код.
    *   `hash("hello")` завжди поверне те саме число.
2.  **Ефективність (Efficiency):** Обчислення хешу має бути дуже швидким.
3.  **Рівномірний розподіл (Uniform Distribution):** Хеш-функція повинна "розкидати" хеш-коди якомога рівномірніше. Вона не повинна групувати різні ключі під однаковими хешами. Це як хороший бібліотекар, що розподіляє книги по всіх полицях, а не ставить усі на одну.

**Вбудована функція `hash()` в Python**
Python має вбудовану функцію `hash()`, яка робить саме це.

```python
print(f"Хеш для числа 100: {hash(100)}")
print(f"Хеш для рядка 'hello': {hash('hello')}")
print(f"Хеш для кортежу (1, 2): {hash((1, 2))}")

# Спробуємо хешувати змінний об'єкт (список)
try:
    hash([1, 2])
except TypeError as e:
    print(f"Помилка: {e}") # Помилка: unhashable type: 'list'
```
Об'єкти, для яких можна обчислити хеш, називаються **хешованими (hashable)**. В Python це всі 
**незмінні (immutable)** типи даних: числа, рядки, кортежі, `frozenset` тощо.

### Частина 2: Хеш-таблиця — "організований склад"**

**Що це таке і як вона влаштована?**
Хеш-таблиця — це, по суті, масив (схожий на список Python), де кожен елемент називається 
**"коміркою"** або **"бакетом" (bucket)**.

**Як працює додавання та пошук елемента (на прикладі словника `d[key] = value`):**

1.  **Крок 1: Обчислення хешу.** Береться ключ (`key`) і для нього обчислюється хеш-код за 
допомогою хеш-функції.
    `hash_value = hash(key)`

2.  **Крок 2: Визначення індексу.** Хеш-код перетворюється на індекс комірки в масиві. Зазвичай 
це робиться за допомогою оператора остачі від ділення `%` на розмір масиву.
    `index = hash_value % len(array)`

3.  **Крок 3: Збереження даних.** У комірку з обчисленим індексом `index` зберігається пара 
`(ключ, значення)`. Ми зберігаємо і ключ, і значення! Це важливо.

**Пошук відбувається за тією ж схемою:** обчислюємо хеш, знаходимо індекс і миттєво переходимо до 
потрібної комірки, щоб взяти звідти значення.

### Частина 3: Колізії — "коли двоє хочуть на одну полицю"**

**Що таке колізія?**
Це ситуація, коли два **різні** вхідні ключі після хешування отримують **однаковий індекс** в 
таблиці.  
`hash("ключ1") % розмір_масиву == hash("ключ2") % розмір_масиву`

Колізії неминучі, оскільки кількість можливих ключів нескінченна, а кількість комірок у таблиці — 
скінченна.

**Як вирішуються колізії? Метод ланцюжків (Separate Chaining)**
Це найпопулярніший метод, який використовується в Python.

*   Кожна комірка хеш-таблиці є не просто місцем для одного елемента, а **вказівником на іншу 
структуру даних** (наприклад, на список або зв'язаний список).
*   Коли відбувається колізія, нова пара `(ключ, значення)` просто додається в кінець цього списку.

**Як тепер працює пошук:**
1.  Обчислюємо хеш ключа, знаходимо індекс комірки.
2.  Переходимо до цієї комірки.
3.  Бачимо там список з кількох елементів (наприклад, `[(ключ1, значення1), (ключ2, значення2)]`).
4.  Проходимо по цьому короткому списку і порівнюємо наш ключ з ключами у списку, щоб знайти 
потрібне значення.

Оскільки хороша хеш-функція розподіляє ключі рівномірно, ці ланцюжки зазвичай залишаються дуже 
короткими, і пошук по них відбувається дуже швидко.

### Частина 4: Реалізація в Python: `dict` та `set`**

**Словник (`dict`) — це класична реалізація хеш-таблиці.**
Коли ви пишете `my_dict['name'] = 'Alice'`, Python "під капотом" виконує всі описані вище кроки:
1.  `hash('name')` -> отримує хеш.
2.  `хеш % розмір_таблиці` -> отримує індекс.
3.  Записує пару `('name', 'Alice')` в комірку за цим індексом (або в ланцюжок, якщо є колізія).

**Множина (`set`) — це теж хеш-таблиця, але простіша.**
Вона працює так само, як словник, але зберігає лише **ключі** (без значень).
Коли ви пишете `my_set.add('apple')`, Python хешує `'apple'`, знаходить індекс і зберігає `'apple'`
в таблиці. Операція `element in my_set` є такою ж швидкою, як і пошук за ключем у словнику.

**Чому ключами можуть бути лише незмінні (immutable) об'єкти?**
Це одна з найважливіших концепцій.
Уявіть, що ви використали список `my_list = [1]` як ключ:
1.  `hash([1])` -> обчислюється хеш, дані зберігаються в таблиці.
2.  Пізніше ви змінюєте список: `my_list.append(2)`. Тепер він виглядає як `[1, 2]`.
3.  Якщо ви знову спробуєте знайти його, `hash([1, 2])` дасть **зовсім інший хеш-код** та інший 
індекс.
4.  Python більше ніколи не зможе знайти оригінальний запис у таблиці! Об'єкт "загубився".

Щоб уникнути цього хаосу, Python вимагає, щоб об'єкти, які використовуються як ключі (і як 
елементи множин), були **незмінними**. Їхній хеш-код гарантовано не зміниться протягом усього 
їхнього життя.

### Частина 5: Продуктивність та Big O

| Операція | Список (`list`) | Хеш-таблиця (`dict`, `set`) | Пояснення |
|:---:|:---:|:---:|:---|
| **Додавання** | O(1) (в середньому) | **O(1)** (в середньому) | Миттєве обчислення індексу. |
| **Пошук елемента** | O(n) | **O(1)** (в середньому) | Це головна перевага! Не потрібно перебирати всі елементи. |
| **Видалення** | O(n) | **O(1)** (в середньому) | Пошук + видалення. |

*   **Середній випадок (O(1) — константний час):** Це те, що ми бачимо у 99% випадків завдяки хорошій хеш-функції. Операція займає однаковий час незалежно від розміру таблиці.
*   **Найгірший випадок (O(n) — лінійний час):** Вкрай рідкісний сценарій, коли всі ключі потрапляють в одну комірку (сильна колізія). Тоді хеш-таблиця вироджується до звичайного списку, і пошук вимагає перебору всіх `n` елементів у цьому ланцюжку.

### Підсумок та ключові висновки

*   **Хеш-функція** перетворює дані на число фіксованого розміру (хеш-код).
*   **Хеш-таблиця** використовує хеш-код для визначення індексу, де зберігати дані, що забезпечує дуже швидкий доступ.
*   **Колізії** — це коли різні ключі дають однаковий індекс. Вони вирішуються за допомогою **методу ланцюжків**.
*   **Словники (`dict`)** та **множини (`set`)** в Python є реалізаціями хеш-таблиць.
*   Ключами в словниках та елементами в множинах можуть бути лише **незмінні (хешовані)** типи даних.
*   Завдяки хеш-таблицям, операції додавання, видалення та пошуку в `dict` та `set` виконуються в середньому за **константний час O(1)**.

---
