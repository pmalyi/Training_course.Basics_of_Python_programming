## Множини в Python (`set`). Основні поняття.  
**Множина (Set)** — це вбудований у Python тип даних, який є невпорядкованою колекцією 
унікальних елементів.  
Якщо ви знайомі з поняттям множин з математики, то set в Python — це його пряма реалізація.  
Основна ідея: Уявіть собі мішок з предметами, де:  
1. Кожен предмет — унікальний (ви не можете покласти в мішок два абсолютно однакових яблука).  
2. Предмети лежать у довільному порядку (немає першого, другого чи останнього).  

На відміну від списків (lists), які є впорядкованими і можуть містити дублікати, множини 
гарантують унікальність і не підтримують індексацію. 

### Створення множин
Є два основних способи створити множину:  
*Спосіб 1*: Використання фігурних дужок {}  
Це найпростіший спосіб створити множину з початковими елементами.  
```python
# Створення множини з різними типами даних
my_set = {1, 2, "hello", 3.14, True}
print(my_set)  # Вивід може бути в іншому порядку, наприклад: {1, 2, 3.14, 'hello', True}

# Створення множини з дублікатами (вони будуть автоматично видалені)
numbers_with_duplicates = {1, 2, 3, 2, 1, 4}
print(numbers_with_duplicates)  # Вивід: {1, 2, 3, 4}
```
**Важливий виняток!** Щоб створити порожню множину, не можна використовувати {}, оскільки це 
синтаксис для створення порожнього словника.

```python
empty_dict = {}
print(type(empty_dict)) # <class 'dict'>
```
Словники у цьому курсі розглядатимуться пізніше.

*Спосіб 2*: Використання конструктора set()  
Цей спосіб використовується для створення порожньої множини, а також для перетворення інших 
ітерабельних об'єктів (списків, кортежів, рядків) на множину.
```python
# Створення порожньої множини
empty_set = set()
print(empty_set)       # Вивід: set()
print(type(empty_set)) # <class 'set'>

# Перетворення списку на множину (видалення дублікатів)
my_list = [1, 'a', 'b', 'a', 2, 1]
my_set_from_list = set(my_list)
print(my_set_from_list)  # Вивід: {1, 2, 'a', 'b'}

# Перетворення рядка на множину унікальних символів
my_string_set = set("hello world")
print(my_string_set)  # Вивід: {'d', 'o', 'l', 'h', 'e', ' ', 'w', 'r'}
```
### Основні властивості множин
- **Невпорядкованість (Unordered):** Елементи в множині не мають фіксованого порядку. Через це ви не 
можете звернутися до елемента за індексом.
```python
my_set = {10, 20, 30}
# print(my_set[0]) # Це викличе помилку TypeError: 'set' object is not subscriptable
```
- **Унікальність елементів (Unique Elements):** Множина не може містити два однакових елементи. 
Це її ключова характеристика.
- **Змінюваність (Mutable):** Ви можете додавати нові елементи до множини або видаляти існуючі. 
Сама структура множини може змінюватися.
- **Елементи мають бути незмінними (Immutable):** Елементами множини можуть бути лише незмінні 
типи даних, такі як числа (int, float), рядки (str), логічні значення (bool) та кортежі (tuple). 
Ви не можете додати до множини список або іншу множину.
```python
# Це працює
valid_set = {1, "text", (1, 2)}

# Це викличе помилку
# invalid_set = {1, 2, [3, 4]}  # TypeError: unhashable type: 'list'
```
*Чому так?* Python використовує хешування для швидкого пошуку елементів, а хешувати можна лише 
незмінні об'єкти.

### Базові операції: Додавання та видалення
- add(element) — додає один елемент до множини. Якщо елемент вже існує, нічого не відбувається.
```python
fruits = {"apple", "banana"}
fruits.add("orange")
print(fruits)  # {'apple', 'banana', 'orange'}
fruits.add("apple") # нічого не зміниться
print(fruits)  # {'apple', 'banana', 'orange'}
```

- update(iterable) — додає всі елементи з ітерабельного об'єкта (наприклад, списку або іншої множини).
```python
fruits = {"apple", "banana"}
more_fruits = ["orange", "mango", "apple"]
fruits.update(more_fruits)
print(fruits)  # {'banana', 'mango', 'apple', 'orange'}
```

- remove(element) — видаляє елемент. Якщо елемента немає в множині, виникає помилка KeyError.
```python
fruits = {"apple", "banana", "orange"}
fruits.remove("banana")
print(fruits)  # {'apple', 'orange'}
# fruits.remove("grape") # KeyError: 'grape'
```

- discard(element) — видаляє елемент. Якщо елемента немає, помилка не виникає. Це безпечніший 
варіант.
```python
fruits = {"apple", "banana", "orange"}
fruits.discard("apple")
print(fruits) # {'banana', 'orange'}
fruits.discard("grape") # помилки не буде
print(fruits) # {'banana', 'orange'}
```

- pop() — видаляє та повертає довільний елемент з множини.

- clear() — видаляє всі елементи з множини, роблячи її порожньою.

### Операції над множинами (математичні операції)

Це найпотужніша частина функціоналу множин. Розглянемо дві множини:
`A = {1, 2, 3}`
`B = {3, 4, 5}`

| Операція | Оператор | Метод | Опис | Приклад | Результат |
|:---:|:---:|:---:|:---|:---|:---:|
| **Об'єднання** | `\|` | `.union()` | Усі елементи з обох множин, без дублікатів | `A \| B` | `{1, 2, 3, 4, 5}` |
| **Перетин** | `&` | `.intersection()` | Тільки спільні елементи для обох множин | `A & B` | `{3}` |
| **Різниця** | `-` | `.difference()` | Елементи, що є в A, але **немає** в B | `A - B` | `{1, 2}` |
| **Симетрична різниця** | `^` | `.symmetric_difference()` | Елементи, що є в A або B, але **не в обох** одночасно | `A ^ B` | `{1, 2, 4, 5}` |

**Приклади в коді:**
```python
set_a = {1, 2, 3, 4}
set_b = {3, 4, 5, 6}

# Об'єднання
union_set = set_a | set_b  # або set_a.union(set_b)
print(f"Об'єднання: {union_set}") # {1, 2, 3, 4, 5, 6}

# Перетин
intersection_set = set_a & set_b # або set_a.intersection(set_b)
print(f"Перетин: {intersection_set}") # {3, 4}

# Різниця
difference_set = set_a - set_b # або set_a.difference(set_b)
print(f"Різниця (A - B): {difference_set}") # {1, 2}

# Симетрична різниця
sym_diff_set = set_a ^ set_b # або set_a.symmetric_difference(set_b)
print(f"Симетрична різниця: {sym_diff_set}") # {1, 2, 5, 6}
```

### Корисні методи та перевірки

*   `len(my_set)` — повертає кількість елементів у множині.
*   `element in my_set` — перевірка наявності елемента. Ця операція **дуже швидка** для множин, набагато швидша, ніж для списків.

```python
my_set = {10, 20, 30}
print(20 in my_set)  # True
print(50 in my_set)  # False
```
*   `issubset(other_set)` (або `A <= B`) — перевіряє, чи є множина `A` підмножиною `B`.
*   `issuperset(other_set)` (або `A >= B`) — перевіряє, чи є множина `A` надмножиною `B`.
*   `isdisjoint(other_set)` — перевіряє, чи не мають множини спільних елементів.

### Практичні випадки використання**

Коли варто використовувати множини?

1.  **Видалення дублікатів зі списку.** Це найпоширеніший випадок.
```python
my_list = [1, 2, 5, 2, 6, 1, 8, 5]
unique_elements = list(set(my_list))
print(unique_elements) # [1, 2, 5, 6, 8] (порядок може бути іншим)
```

2.  **Швидка перевірка наявності.** Якщо вам потрібно часто перевіряти, чи є елемент у великій 
колекції, множина працюватиме значно швидше за список.
```python
# Приклад: знайти унікальних відвідувачів сайту з великого лог-файлу
user_ids = [101, 102, 103, 101, 104, 102, ...] # Дуже довгий список
unique_visitors = set(user_ids)

if 101 in unique_visitors: # Дуже швидко!
    print("Користувач 101 відвідував сайт.")
```

3.  **Порівняння даних:**
    *   Знайти спільних друзів у двох користувачів (перетин).
    *   Знайти товари, які є в одному магазині, але немає в іншому (різниця).
    *   Скласти повний список тегів з кількох статей (об'єднання).

### Підсумок

*   **Множина (`set`)** — це невпорядкована колекція **унікальних** та **незмінних** елементів.
*   Створюються за допомогою `{...}` або конструктора `set()`. Порожня множина — тільки `set()`.
*   Не підтримують індекси, але дозволяють швидко додавати, видаляти та перевіряти наявність елементів.
*   Основна сила множин — у математичних операціях: об'єднання (`|`), перетин (`&`), різниця (`-`) та симетрична різниця (`^`).
*   Ідеально підходять для задач, пов'язаних з унікальністю, членством та порівнянням наборів даних.

---
