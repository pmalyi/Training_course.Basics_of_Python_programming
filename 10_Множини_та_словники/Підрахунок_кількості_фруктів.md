### Задача: Підрахунок кількості фруктів у кошику
Дано список, який представляє фрукти в кошику. Деякі фрукти повторюються, і наше завдання — створити словник, 
де ключем буде назва фрукта, а значенням — скільки разів він зустрічається у списку.

**Вхідні дані:**
```python
fruits_basket = ["яблуко", "груша", "банан", "яблуко", "апельсин", "груша", "яблуко"]
```
**Очікуваний результат:**
```
{'яблуко': 3, 'груша': 2, 'банан': 1, 'апельсин': 1}
```

Спробуємо розв'язати цю задачу такими способами:

### **Спосіб 1: БЕЗ використання методу `.get()`**

Цей підхід вимагає вручну перевіряти, чи існує вже ключ у словнику, перш ніж оновлювати його значення.

```python
def count_fruits_without_get(basket):
    """
    Підраховує фрукти, використовуючи перевірку `if key in dict`.
    """
    fruit_counts = {}  # 1. Створюємо порожній словник для результатів
    
    for fruit in basket:
        # 2. Для кожного фрукта у списку...
        
        # 3. Перевіряємо, чи такий фрукт вже є ключем у нашому словнику
        if fruit in fruit_counts:
            # 4a. Якщо так - збільшуємо його лічильник на 1
            fruit_counts[fruit] = fruit_counts[fruit] + 1
        else:
            # 4b. Якщо ні - додаємо цей фрукт у словник з початковим значенням 1
            fruit_counts[fruit] = 1
            
    return fruit_counts

# --- Використання ---
fruits_basket = ["яблуко", "груша", "банан", "яблуко", "апельсин", "груша", "яблуко"]
counts = count_fruits_without_get(fruits_basket)
print("Результат БЕЗ .get():")
print(counts)  # {'яблуко': 3, 'груша': 2, 'банан': 1, 'апельсин': 1}
```

**Як це працює (покроково для "яблуко"):**
1.  **Перше "яблуко":** `if "яблуко" in fruit_counts` повертає `False`. Виконується блок `else`, і 
`fruit_counts` стає `{'яблуко': 1}`.
2.  **Друге "яблуко":** `if "яблуко" in fruit_counts` повертає `True`. Виконується блок `if`, і значення для 
"яблука" оновлюється: `fruit_counts['яблуко'] = 1 + 1`, стає 2.
3.  **Третє "яблуко":** `if "яблуко" in fruit_counts` повертає `True`. Значення оновлюється: 
`fruit_counts['яблуко'] = 2 + 1`, стає 3.

Цей код абсолютно правильний і працює, але він трохи громіздкий. Логіка розбита на дві гілки (`if/else`), 
хоча ми робимо концептуально одну й ту саму річ — оновлюємо лічильник.


### **Спосіб 2: З використанням методу `.get()`**

Цей підхід дозволяє об'єднати логіку `if/else` в один елегантний рядок.

```python
def count_fruits_with_get(basket):
    """
    Підраховує фрукти, використовуючи елегантний метод .get().
    """
    fruit_counts = {} # 1. Створюємо порожній словник
    
    for fruit in basket:
        # 2. Для кожного фрукта в списку...
        # 3. Оновлюємо лічильник в один рядок!
        # .get(fruit, 0) - отримати поточне значення для `fruit`.
        # Якщо ключа `fruit` немає, повернути 0.
        # Потім до отриманого значення (поточного чи 0) додаємо 1.
        fruit_counts[fruit] = fruit_counts.get(fruit, 0) + 1
        
    return fruit_counts

# --- Використання ---
fruits_basket = ["яблуко", "груша", "банан", "яблуко", "апельсин", "груша", "яблуко"]
counts = count_fruits_with_get(fruits_basket)
print("Результат з .get():")
print(counts)    # {'яблуко': 3, 'груша': 2, 'банан': 1, 'апельсин': 1
```

**Як це працює (покроково для "яблуко"):**
1.  **Перше "яблуко":** `fruit_counts.get("яблуко", 0)` повертає `0`, тому що ключа ще немає. Вираз стає 
`fruit_counts["яблуко"] = 0 + 1`. Словник: `{'яблуко': 1}`.
2.  **Друге "яблуко":** `fruit_counts.get("яблуко", 0)` повертає `1`, тому що ключ вже існує. Вираз стає 
`fruit_counts["яблуко"] = 1 + 1`. Словник: `{'яблуко': 2}`.
3.  **Третє "яблуко":** `fruit_counts.get("яблуко", 0)` повертає `2`. Вираз стає `fruit_counts["яблуко"] = 2 + 1`. 
Словник: `{'яблуко': 3}`.

Логіка для нового та існуючого ключа об'єднана в одному рядку. Це більш стисло, читабельно і вважається більш 
"пайтонічним" (Pythonic) стилем.


### **Спосіб 3: Розв'язання з використанням `collections.Counter`**

Цей підхід зводить усе завдання до одного рядка.

```python
# 1. Імпортуємо клас Counter з модуля collections
from collections import Counter

def count_fruits_with_counter(basket):
    """
    Підраховує фрукти за допомогою спеціалізованого класу Counter.
    """
    # 2. Просто передаємо наш список у конструктор Counter
    fruit_counts = Counter(basket)
    return fruit_counts

# --- Використання ---
fruits_basket = ["яблуко", "груша", "банан", "яблуко", "апельсин", "груша", "яблуко"]
counts = count_fruits_with_counter(fruits_basket)
print("Результат з використанням Counter:")
print(counts)
```

**Результат:**
```
Результат з використанням Counter:
Counter({'яблуко': 3, 'груша': 2, 'банан': 1, 'апельсин': 1})
```
Як бачите, це надзвичайно просто та елегантно.

#### **Що таке `collections.Counter`?**

`Counter` — це "прокачаний" словник, спеціально створений для підрахунку хешованих об'єктів.

**Ключові особливості:**

1.  **Створений для підрахунку:** Його головна мета — лічити елементи.
2.  **Є підкласом `dict`:** Він успадковує всі методи звичайного словника (`.keys()`, `.values()`, `.items()` 
тощо), тому ви можете працювати з ним як зі звичайним `dict`.
3.  **Автоматично обробляє відсутні ключі:** Якщо ви спробуєте отримати доступ до лічильника для елемента, 
якого немає в `Counter`, він не викличе помилку `KeyError`, а просто поверне `0`.
```python
print(counts['слива']) # Виведе: 0
```
4.  **Може бути ініціалізований напряму з будь-якої ітерабельної послідовності** (списку, кортежу, рядка). 
"Під капотом" він сам пройдеться по всіх елементах і порахує їх.

#### **Додаткові можливості `Counter`, яких немає у звичайних словників**

`Counter` має кілька дуже корисних унікальних методів.

**1. Метод `most_common(n)`**
Він повертає список з `n` найпоширеніших елементів та їхніх лічильників, відсортований за спаданням.

```python
# Знайти 2 найпопулярніші фрукти
print("\nДва найпоширеніші фрукти:")
print(counts.most_common(2)) 
# Виведе: [('яблуко', 3), ('груша', 2)]

# Якщо не вказати n, поверне всі елементи
print("\nУсі фрукти, відсортовані за популярністю:")
print(counts.most_common())
# Виведе: [('яблуко', 3), ('груша', 2), ('банан', 1), ('апельсин', 1)]
```

**2. Математичні операції**
Лічильники можна додавати та віднімати, що дуже зручно для порівняння наборів даних.

```python
another_basket = Counter(["яблуко", "полуниця", "полуниця"])
# {'яблуко': 1, 'полуниця': 2}

# Додавання лічильників
total_counts = counts + another_basket
print(f"\nЗагальна кількість фруктів: {total_counts}")
# Виведе: Counter({'яблуко': 4, 'груша': 2, 'полуниця': 2, 'банан': 1, 'апельсин': 1})

# Віднімання лічильників (залишаються тільки додатні результати)
difference = counts - another_basket
print(f"Різниця (перший кошик мінус другий): {difference}")
# Виведе: Counter({'яблуко': 2, 'груша': 2, 'банан': 1, 'апельсин': 1})
# Зверніть увагу: 'полуниця' зникла, бо 0 - 2 < 0.
```
Коли ваше завдання — порахувати кількість входжень елементів у колекцію, **`collections.Counter` — це ваш 
найкращий друг**. Він не лише спрощує код до одного рядка, а й робить його більш читабельним, швидким та надає 
потужні інструменти для подальшого аналізу даних.

### **Спосіб 4: Розв'язання з використанням `collections.defaultdict`**

Цей підхід робить код всередині циклу надзвичайно чистим.

```python
# 1. Імпортуємо клас defaultdict з модуля collections
from collections import defaultdict

def count_fruits_with_defaultdict(basket):
    """
    Підраховує фрукти за допомогою defaultdict, який автоматично
    ініціалізує нові ключі значенням за замовчуванням.
    """
    # 2. Створюємо defaultdict. Як аргумент передаємо функцію-фабрику,
    # яка буде викликана для створення значення для нового ключа.
    # int() без аргументів повертає 0.
    fruit_counts = defaultdict(int)
    
    for fruit in basket:
        # 3. Просто збільшуємо лічильник.
        # Ніяких перевірок `if` або викликів `.get()` не потрібно!
        fruit_counts[fruit] += 1
        
    return fruit_counts

# --- Використання ---
fruits_basket = ["яблуко", "груша", "банан", "яблуко", "апельсин", "груша", "яблуко"]
counts = count_fruits_with_defaultdict(fruits_basket)
print("Результат з використанням defaultdict:")
print(counts)   # defaultdict(<class 'int'>, {'яблуко': 3, 'груша': 2, 'банан': 1, 'апельсин': 1})
```

**Як це працює? Магія `defaultdict`**

`defaultdict` — це словник, який вміє сам себе ініціалізувати. Він поводиться як звичайний словник, за одним 
винятком:

**Якщо ви намагаєтеся отримати доступ до ключа, якого не існує, він не викликає `KeyError`.**

Замість цього він робить наступне:
1.  Викликає **"фабрику за замовчуванням"** (`default factory`), яку ви передали в конструктор (у нашому випадку 
це `int`).
2.  Результат роботи цієї фабрики (для `int()` це `0`) використовується як значення для **нового** ключа.
3.  Ця нова пара `ключ: значення` додається до словника.
4.  Нарешті, повертається це нове значення.

**Покроковий розбір для нашого прикладу:**
1.  **Перше "яблуко":**
    *   Спроба виконати `fruit_counts["яблуко"] += 1`.
    *   Ключа `"яблуко"` у словнику немає.
    *   `defaultdict` викликає фабрику: `int()`, яка повертає `0`.
    *   `defaultdict` сам створює запис: `fruit_counts["яблуко"] = 0`.
    *   Тепер виконується оригінальна операція: `fruit_counts["яблуко"] += 1` (тобто `0 + 1`).
    *   Результат: `fruit_counts` тепер `defaultdict(<class 'int'>, {'яблуко': 1})`.

2.  **Друге "яблуко":**
    *   Спроба виконати `fruit_counts["яблуко"] += 1`.
    *   Ключ `"яблуко"` **вже існує** зі значенням `1`.
    *   `defaultdict` поводиться як звичайний словник.
    *   Виконується операція `1 + 1`.
    *   Результат: `fruit_counts` тепер `defaultdict(<class 'int'>, {'яблуко': 2})`.

**Інші корисні застосування `defaultdict`**

`defaultdict` є більш загальним інструментом, ніж `Counter`. Його часто використовують для групування даних.

**Приклад: Групування слів за першою літерою**
```python
from collections import defaultdict
words = ["яблуко", "апельсин", "груша", "банан", "гранат", "ананас"]

# Фабрика `list` створює порожній список для нових ключів
grouped_words = defaultdict(list)

for word in words:
    first_letter = word[0]
    grouped_words[first_letter].append(word)

print("\nСлова, згруповані за першою літерою:")
# Зверніть увагу, що результат - це defaultdict, але його можна використовувати як звичайний dict
print(dict(grouped_words))
```
**Результат:**
```
Слова, згруповані за першою літерою:
{'я': ['яблуко'], 'а': ['апельсин', 'ананас'], 'г': ['груша', 'гранат'], 'б': ['банан']}
```

### **Фінальна таблиця порівняння всіх чотирьох способів**

| Характеристика | Підхід з `if/else` | Підхід з `.get()` | Підхід з `defaultdict` | Підхід з `Counter` |
| :--- | :--- | :--- | :--- | :--- |
| **Стислість** |  verbose | good | very good | **excellent** (one-liner) |
| **Читабельність**| low | good | very good | **excellent** (intent is clear) |
| **Продуктивність**| good | good | **excellent** | **excellent** |
| **Функціональність**| basic | basic | general-purpose grouping | **specialized for counting** |
| **Основна ідея** | Ручна перевірка | Безпечний доступ | Автоматична ініціалізація | Все-в-одному |
| **Найкраще для...**| Навчання | Безпечний доступ до даних | **Групування даних** | **Підрахунок частоти** |

**Висновок:**

*   `defaultdict(int)` є чудовим і дуже елегантним способом для вирішення задачі підрахунку, значно спрощуючи 
логіку всередині циклу.
*   Однак для **конкретної задачі підрахунку** `Counter` залишається найкращим вибором, оскільки він створений 
саме для цього, є більш виразним (його назва говорить сама за себе) і надає додаткові корисні методи, як-от 
`most_common()`.
*   `defaultdict` є кращим у задачах **групування**, де вам потрібно додавати елементи до списків або множин, 
асоційованих з ключами.



