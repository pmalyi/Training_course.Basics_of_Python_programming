## Поняття функції. Використання функцій
**Функція** – це блок коду, який виконує певну задачу та може бути викликаний багаторазово. Функції 
дозволяють уникати повторення коду, покращують його читабельність і спрощують тестування та 
налагодження програм.  
Функції у програмуванні дещо відрізняються від математичних функцій. У математиці функції можуть
лише отримати аргументи і повернути результат, а в програмуванні, функції здійснивши деякі обчислювальні 
процеси, можуть нічого не повертати, але щось друкувати чи змінювати стан змінних.  

Створювати функції доцільно, якщо одні й ті самі дії потрібно виконувати кілька разів. 
Іноді деякі логічні блоки роботи з програмою теж зручно оформляти як функції. Коли програма "розростається", 
відстежити все стає дуже складно. У межах однієї невеликої функції заплутатися набагато складніше, оскільки
відомо, що вона отримує на вхід, що має видати, а про решту програми у цей час можна не думати.

У програмуванні також вважається хорошим стилем писати функції, що поміщаються на один екран. Тоді 
можна одночасно оглянути всю функцію і не потрібно скролити текст. Тому, якщо код виходить надто великим,
потрібно "нарізати його на шматочки" так, щоб кожен з них був логічним (робив якусь певну дію, якій можна
дати назву) і не перевищував при цьому 10-15 рядків.

Ми вже використовували готові функції, такі як print, len та деякі інші. Ці функції описані в 
стандартній бібліотеці або інших бібліотеках, що підключаються.  

### Приклад використання функції
Розглянемо, як створити свою функцію на прикладі обчислення факторіалу. Текст програми без функції
виглядає так:

```python
n = int(input())
fact = 1
i = 2
while i <= n:
    fact *= i
    i += 1
print(fact)
```
Обчислення факторіалу можна винести у функцію, тоді ця ж програма виглядатиме так:
```python
# Оголошення функці
def factorial(num):
    fact = 1
    i = 2
    while i <= num:
        fact *= i
        i += 1
    return fact

n = int(input())
# Виклик функції
result = factorial(n)
print(result)
```
Опис функції має йти на початку програми. Насправді він може бути в будь-якому місці, перш ніж
викликати функцію `factorial`.  
Визначення функції повинне починатися зі слова def (скорочення від `define`, визначити). Далі йде ім'я 
функції, після якого в дужках через кому перераховуються параметри (у нашої функції лише один параметр).
Після закриття дужки має стояти двокрапка.  
Команди, що виконуються у функції, повинні записуватися з відступом, як у блоках команд if або while.  
У нашій функції `num` - це параметр, на його місце підставляється значення `n`, з яким функція була викликана.
`n` - це аргумент функції.
Дії всередині функції такі самі, як у звичайній програмі, крім додаткової команди `return`. Команда 
`return` повертає значення функції (воно має бути записано через пропуск після слова `return`) і 
припиняє її роботу. Повернене значення підставляється у те місце, де здійснювався виклик функції.  
Команда `return` може зустрічатися у будь-якому місці функції. Після того, як вона виконається, роботу
функції буде припинено. Тут є деяка аналогія з командою `break`, яка застосовується для виходу з циклу.

Розглянемо ще один приклад.  
Написати функцію пошуку максимуму з двох чисел, які передаються їй як параметри:
```python
def max2(a, b):
     if a > b:
         return a
     else:
         return b
```
Її можна записати і по-іншому:
```python
def max2(a, b):
     if a > b:
         return a
     return b
```
Якщо умова в `if`'і була істинною, то виконається команда `return a` і виконання функції буде припинено - 
до команди `return b` виконання просто не дійде.

За допомогою функції `max2` можна реалізувати функцію `max3`, що повертає максимум із трьох чисел:
```python
def max2(a, b):
     if a > b:
         return a
     return b

def max3(a, b, c):
     return max2(max2(a, b), c)

print(max3(7, 3, 5))  # 7
```
Ця функція двічі викликає `max2`: спочатку для вибору максимуму серед чисел `a` і `b`, а потім для вибору 
максимуму між знайденим значенням і числом `c`, що залишилося.

Тут слід звернути увагу, що як аргумент функції може передаватися не лише змінна чи константне значення,
а і результат обчислення будь-якого арифметичного виразу. Наприклад, результат, повернутий іншою функцією.

Наші функції `max2` і `max3` будуть працювати не тільки для чисел, але й для будь-яких порівнюваних 
об'єктів, наприклад для рядків, що яскраво демонструє принцип **Duck Typing** у Python. 

***Довідка***  
**Duck typing** — це концепція в динамічно типізованих мовах програмування, зокрема в Python, яка означає,
що тип об'єкта визначається не його класом, а тим, які методи та атрибути він має. Іншими словами,
якщо об'єкт поводиться як певний тип, його можна використовувати як цей тип, незалежно від його фактичного
класу.  
**Суть принципу**  
Принцип можна пояснити висловом:
*"Якщо щось ходить як качка, крякає як качка і виглядає як качка, то, ймовірно, це качка."*

Python дозволяє використовувати об'єкти без явної перевірки їхнього типу, якщо вони підтримують необхідну
поведінку.

Зазвичай не потрібно явно вказувати на який тип параметрів функція очікує, тому що Python - 
це мова з динамічною типізацією. Але, наприклад, у мові C типи анотуються, тобто явно 
вказується, якого типу має бути параметр функції та якого типу значення, що повертаються. 
У Python останніх версій з'явилася можливість анотувати типи, і робиться це за допомогою 
двокрапки для параметрів, а стрілочкою вказують тип значення, який функція повертає. 
Однак, якщо ми передамо параметри інших типів у функцію, код все одно виконається, тому що 
Python - це динамічна мова, і анотація типів покликана лише допомогти програмісту чи його 
IDE відловити якісь помилки.
```python
def add(x: int, y: int) -> int:
    return x + y

print(add(10, 11)) # 21
print(add('still', 'works'))  # still works
```

### Виклики функцій з функції
Функцію підрахунку факторіалу можна використовувати для підрахунку біноміальних коефіцієнтів 
(кількості невпорядкованих виборів). Класичним завданням комбінаторики є завдання про кількість невпорядкованих виборів
без повторень, зміст якого можна висловити: скільки способами можна вибрати k з n різних предметів? Формула для 
підрахунку кількості невпорядкованих виборів є такою: `n! /(k!*(n - k)!)`.
Якби ми не користувалися функціями, то нам потрібно було б тричі записати майже одне й те саме. 
За допомогою функцій обчислення виглядає набагато простіше:

```python
def factorial(num):
    fact = 1
    i = 2
    while i <= num:
        fact *= i
        i += 1
    return fact

n, k = map(int, input().split())
print(factorial(n) // (factorial(k) * factorial(n - k)))
```

Підрахунок біномних коефіцієнтів можна оформити у вигляді функції з двома параметрами:

```python
def factorial(num):
    fact = 1
    i = 2
    while i <= num:
        fact *= i
        i += 1
    return fact

def binomial(n, k):
    return factorial(n) // (factorial(k) * factorial(n - k))

n, k = map(int, input().split())
print(binomial(n, k))
```
### Функції без параметрів
Функція може не отримувати жодного параметра і, як вже було сказано, може не повертати результату.
```python
# Оголошення функції
def say():
    print("Привіт, Python!")

# Виклик функції
say() # Привіт, Python!
```
Функція `say()`не містить команди `return`, однак вона повертає дефолтне значення - `None`

### Параметри за замовчуванням
Функція може мати дефолтні параметри
```python
def say(name, greeting="Привіт"):
    print(f"{greeting}, {name}!")

say("Іван")      # Привіт, Іван!
say("Іван", "Hello")  # Hello, Іван!
```
У функції `say` `greeting` є дефолтним параметром.

### Іменовані аргументи
```python
def say(name, greeting):
    print(f"{greeting}, {name}!")

say(name="Іван", greeting="Hello")      # Hello, Іван!
say(greeting="Привіт", name="John")     # Привіт, John!
```
У виклику функції `say` обидва аргументи є іменованими і можуть записуватися у довільному порядку.

### Повернення кількох значень функцією
Розглянемо випадок, коли функція повинна повернути кілька значень з прикладу функції, яка впорядковує
два числа. Щоб повернути декілька значень, достатньо записати їх у `return` через кому. Аналогічно, 
через кому мають бути перераховані змінні, яким будуть присвоєні обчислені значення у виклику функції.
```python
def sort2(a, b):
     if a < b:
         return a, b
     return b, a

a = int(input())
b = int(input())
minimum, maximum = sort2(a, b)
print(minimum, maximum)
```
Насправді, при перерахуванні значень через кому у команді `return` формуються об'єкти типу "кортеж", 
їх докладне вивчення буде пізніше. Наявних знань вам достатньо щоб використовувати функції, які повертають кілька значень.

### Повернення логічних значень
Іноді зручно оформляти навіть прості речі у вигляді функцій, щоб підвищити читабельність програми. 
Наприклад, якщо потрібно перевірити число на парність, то значно зручніше щоразу викликати функцію 
`isEven(n)`, а не писати щоразу `n % 2 == 0`.   
Така функція може виглядати так:
```python
def isEven(n):
     return n % 2 == 0
```
Результатом роботи цієї функції буде істина чи хибність. Тепер функцію дуже зручно застосовувати в `if`'ах:
```python
def isEven(n):
     return n % 2 == 0

if isEven(n):
     print("EVEN")
else:
     print("ODD")
```
Якщо є складений логічний вираз, то краще оформити його у вигляді функції з зрозумілою назвою - так 
програму буде легше читати, а ймовірність помилок в ній знизиться. Функції, які повертають значення 
логічного типу прийнято називати, починаючи із слова *is*.

### Локальні та глобальні змінні
Розглянемо приклад:
```python
def foo():
     print(a)

a = 1
foo() # 1
```
Цей код надрукує **1** та виконається без помилок. Змінна `a` - глобальна, тому ми можемо дивитися на
її значення з будь-якої функції. На момент виклику функції `foo` змінна `a` вже створена, хоча опис
функції йде раніше присвоювання.

Якщо ж ініціалізувати змінну всередині функції, використовувати її поза функцією не можна. Наприклад, 
такий код:
```python
def f():
     a = 1
f()
print(a)
```
завершиться з помилкою `NameError: name 'a' is not defined` (змінна `a` не визначена). Змінні значення 
яких змінюються всередині функції за замовчуванням вважаються локальними, тобто доступними лише усередині 
функції. Як тільки функція закінчує свою роботу, змінна знищується.

Таким чином, якщо у функції відбувалося присвоєння якоїсь змінної, то ця змінна вважається локальною. 
Якщо присвоювань не відбувалося, то змінна вважається глобальною.

Локальні змінні можна називати такими ж іменами, як глобальні. Наприклад, вивід такого коду:
```python
def foo():
     a = 1
     print(a, end=' ') # 1
a = 0
foo()
print(a) # 0
```
буде `1 0`. Спочатку відбудеться виклик функції `foo`, у якій буде створено локальну змінну `a` зі 
значенням `1` (отримати доступ до глобальної змінної `a` з функції тепер не можна), потім функція 
закінчить свою роботу і буде виведена глобальна змінна `a`, зі значенням якої нічого не сталося.

Змінна вважається локальною навіть у разі, якщо її присвоєння відбувалося всередині умовного оператора
(навіть якщо він ніколи не виконається):
```python
def foo():
     print(a)
     if False:
         a = 0
a = 1
foo()
```
Ця програма завершиться з помилкою `UnboundLocalError: local variable 'a' referenced before assignment` (звернення 
до змінної до ініціалізації). Будь-яке надання значення змінної всередині тіла функції робить змінну
локальною.

За допомогою спеціальної команди `global` можна зробити так, що функція зможе змінити значення глобальної
змінної. Для цього потрібно записати слово `global`, а потім через кому перерахувати імена глобальних
змінних, які функція зможе змінювати. Наприклад, такий код:
```python
def foo():
     global a
     a = 1
     print(a, end=' ') # 1
a = 0
foo()
print(a) # 1
```
виведе "1 1", оскільки значення глобальної змінної буде змінено всередині функції.

Всі параметри функції є локальними змінними із значеннями, які були передані в функцію. Параметри також 
можна змінювати і це ніяк не вплине на значення змінних там, звідки була викликана функція (якщо тип 
об'єктів-параметрів був незмінним, наприклад: цілі числа, дійсні числа, рядки).

Використання глобальних змінних як для читання, так і для запису усередині функцій - дуже поганий тон
програмування. Це пов'язано з тим, що може виникнути потреба використовувати деякі окремі функції 
з програми, які не працюватимуть поза даною програмою у разі використання глобальних змінних.  
Все необхідне для роботи функції бажано передаватися через параметри.

