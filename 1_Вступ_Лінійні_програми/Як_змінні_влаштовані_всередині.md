## Як змінні влаштовані всередині

### Поняття змінної та її робота у пам’яті
Змінна у Python — це не просто контейнер для даних, а посилання на об'єкт у пам'яті. Коли ви створюєте змінну, Python:
1. Виділяє пам’ять для значення.
2. Створює об'єкт цього значення.
3. Присвоює змінній посилання на цей об'єкт.

У мові Python усі змінні є посиланнями на об'єкти. Кожен об'єкт має тип (int, float і str) і значення, у нашому 
випадку конкретне число чи послідовність символів.  
Змінні (посилання) у мові Python зручно уявляти собі як бірочки (ярлички) на мотузці, які прив'язані до якогось 
об'єкта. Взагалі кажучи, до одного об'єкта може бути прив'язано скільки завгодно багато бірочок. Різні змінні з
однаковим значенням фактично є ярликами, прив'язаними до того самого об'єкта.

### Динамічна типізація
Python є мовою з динамічною типізацією, тобто змінні можуть змінювати свій тип під час виконання програми.
```python
x = 10       # int
x = "Hello"  # str (тип змінився)
```

### Ідентифікатор об’єкта
Кожен об’єкт у Python має унікальний ідентифікатор (адресу в пам’яті), який можна отримати через `id()`:
```python
x = 5
print(id(x))
```

### Посилання на один об’єкт
Якщо дві змінні мають однакове значення, вони можуть вказувати на один і той самий об'єкт:
```python
a = 10
b = a
print(id(a) == id(b))  # True
```
Але для змінних змінюваних типів (списки, словники) копіювання працює інакше.

### Змінюввані та незмінювані типи
- **Незмінювані** (immutable): `int`, `float`, `str`, `tuple`
- **Змінювані** (mutable): `list`, `dict`, `set`  

Типи int, float і str в Python є незмінюваними. Будь-яке присвоєння в Python неспроможне змінити незмінюваний тип, 
а може лише змінити місце, куди вказує посилання (і, за необхідності, сформувати новий об'єкт).
Наприклад, команда `x = 2` приведе спочатку до створення об'єкта типу "ціле число" зі значенням 2 у пам'яті, а 
потім до створення змінної $x$, яка буде посиланням на цей об'єкт.
Якщо після цього написати `y = 2`, то новий об'єкт зі значенням 2 створюватися не буде, а створиться тільки нове 
посилання з ім'ям y, що показує на той самий об'єкт, що і посилання x.  
Якщо тепер написати рядок `x = 3`, то з об'єктом зі значенням 2 нічого не станеться, адже він незмінний.  
Створиться новий об'єкт зі значенням 3, посилання $x$ відв'яжеться від об'єкта зі значенням 2 і прив'яжеться до 
нового об'єкта 3. При цьому до об'єкта 2 залишиться зв'язане посилання $y$.  
Якщо змінити значення змінної $y$, то у об'єкта 2 не залишиться посилань на нього. Тому він може бути безболісно
знищений при збиранні сміття, адже отримати до нього доступ вже неможливо - на нього не посилається жодна змінна.   
Константні значення програми (наприклад, явно задані числа у вихідному коді програми) також є посиланнями на 
об'єкти, вміст яких збігається зі значенням цих констант. Однак ці посилання не можуть бути змінені і не можуть 
брати участь у присвоєнні з лівого боку знаку $=$.  

При зміні незмінюваного об’єкта створюється новий об’єкт:
```python
x = "hello"
x = x + " world"  # Створюється новий рядок
```

А от у випадку зі списком зміни відбуваються на місці:
```python
lst = [1, 2, 3]
lst.append(4)  # Той самий об’єкт у пам'яті змінюється
```
Розуміння внутрішньої роботи змінних допомагає ефективно керувати пам’яттю та уникати несподіваних ефектів у коді.


