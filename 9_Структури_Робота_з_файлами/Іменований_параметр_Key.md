###  Іменований параметр key у Python
Іменований параметр **key** дозволяє вказати критерій порівняння для функцій, які працюють зі списками 
або іншими послідовностями.

Використовується у функціях:
- sorted()
- min()
- max()

та методі sort() колекцій, які його підтримують.   
Ці функції за замовчуванням порівнюють елементи напряму, але **key** дозволяє задати функцію, яка обчислює
ключ для сортування або порівняння.

Функція **key** приймає функцію одного аргументу, яка повертає значення, що буде використовуватись для
порівняння.  

#### Приклади використання key
Приклад. Для кожної людини задано ріст та ім'я. Необхідно впорядкувати їх за ростом в порядку зростання,
а у разі однакового росту - в алфавітному порядку.
```python
peopleList = [(178, "Ярослав"), (180, "Петро"), (178, "Володимир"), (183, "Олег")]
peopleList.sort()
for manData in peopleList:
    print(' '.join(map(str, manData)))

# Вивід:
# 178 Володимир
# 178 Ярослав
# 180 Петро
# 183 Олег
```
У цьому прикладі нам пощастило і вдалося скласти список, який містить параметри людей, які порівнюються,
в потрібному порядку. Часто зустрічаються неприємніші ситуації. Розглянемо те саме завдання, але тепер
людей потрібно впорядкувати за спаданням росту, але у разі однакового росту вони, як і раніше, повинні
бути впорядковані за алфавітом. Просте використання reversed=True не дасть бажаного результату: люди з
однаковим ростом стоятимуть у неправильному алфавітному порядку.
```python
peopleList = [(178, "Ярослав"), (180, "Петро"), (178, "Володимир"), (183, "Олег")]
peopleList.sort(reverse=True)
for manData in peopleList:
    print(' '.join(map(str, manData)))

# Вивід:
# 183 Олег
# 180 Петро
# 178 Ярослав
# 178 Володимир
```
Можна застосувати хитрість і перетворити ріст кожної людини на від'ємне число, модуль якого дорівнюватиме
початковому росту. Після цього список можна просто впорядкувати за зростанням – найвищі люди матимуть найменший 
від'ємний "ріст", за яким відбувається порівняння насамперед. Перед виведенням необхідно перетворити 
ріст назад на додатне число.
```python
peopleList = [(178, "Ярослав"), (180, "Петро"), (178, "Володимир"), (183, "Олег")]
for i in range(len(peopleList)):
    peopleList[i] = -peopleList[i][0], peopleList[i][1]
peopleList.sort()
for i in range(len(peopleList)):
    peopleList[i] = -peopleList[i][0], peopleList[i][1]
    print(' '.join(map(str, peopleList[i])))

# Вивід:
# 183 Олег
# 180 Петро
# 178 Володимир
# 178 Ярослав
```
#### Параметр key у методі sort 
Для реалізації нестандартних сортувань краще не спотворювати вихідні дані, а використовувати параметр **key**,
що передається у функцію сортування.  
Значенням цього параметра має бути функція, яка застосовується до кожного елемента списку, а потім порівняння
елементів відбувається за значенням цієї функції (воно називається ключем).  
```python
def foo(T):
    return -T[0], T[1]

peopleList = [(178, "Ярослав"), (180, "Петро"), (178, "Володимир"), (183, "Олег")]
peopleList.sort(key=foo)
for people in peopleList:
    print(' '.join(map(str, people)))

# Вивід:
# 183 Олег
# 180 Петро
# 178 Володимир
# 178 Ярослав
```
Розглянемо такий приклад: необхідно впорядкувати введені рядки по довжині, а у разі рівної довжини залишити їх
у порядку, як вони йшли у вхідному файлі. Наприклад, для вхідних рядків "c", "abb", "b" правильною відповіддю
має бути "c", "b", "abb" ("c" йде раніше "b", тому що вони мають рівну довжину, але "c" розміщено у вхідних даних
перед "b").
На щастя, сортування, яке використовується в Python має властивість стійкості (stable), тобто для елементів із
рівним ключем зберігається їхній взаємний порядок.
Розв'язання цього завдання буде виглядати так:
```python
strings = ["c", "abb", "b" ]
print('\n'.join(sorted(strings, key=len)))

# Вивід:
# c
# b
# abb
```
Як ще один приклад розглянемо задачу про сортування точок на площині, заданих парою цілих координат x і y по
неспаданню відстані від початку координат. В даному випадку у функцією для генерації ключа, по якому будуть
порівнюватися елементи, буде функція, яку ми напишемо і яка повертатиме квадрат відстані від точки до початку
координат. Квадрат відстані ми використовуємо для того, щоб залишатися в цілих числах і позбавиться 
необхідності шукати квадратний корінь (повільно і неточно):
```python
def dist(point):
    return point[0] ** 2 + point[1] ** 2

points = [(7, 1), (4, 5), (5, -3), (-6, -6)]
points.sort(key=dist)
for point in points:
    print(' '.join(map(str, point)))

# Вивід
# 5 -3
# 4 5
# 7 1
# -6 -6
```
